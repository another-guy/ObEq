{
  "name": "ObEq",
  "tagline": "Quick, easy, and correct implementation of object equality in .NET",
  "body": "ï»¿## Synopsis\r\n\r\nObEq (from ObjectEquality) provides basic implementation for GetHashCode and Equals methods.\r\n\r\n## Code Example\r\n\r\nLet's assume there is a class Sample<T> that has two fields.\r\nIt could be defined this way:\r\n\r\n```cs\r\npublic class Sample<T>\r\n{\r\n    private readonly T field1;\r\n    private readonly int field2;\r\n\r\n    // Constructor(s)...\r\n\r\n    // Other methods and properties...\r\n}\r\n```\r\n\r\nIf we need this class to implement GetHashCode() and Equals() methods, it could be easily achieved using ObEq's EqualityHelper class.\r\n\r\n### Implementing IMemberwiseComparable\r\n\r\nFirst step is to make the target type implement the `IMemberwiseComparable` interface.\r\nThis will enforce the type to define EqualityMembers property refers to all fields that should be used as equality members.\r\n\r\n**IMPORTANT**\r\nThe referred fields should be declared as `readonly` otherwise the calculated hash code value can change every time any field value is modified.\r\nWhile it's technically possible to use not `readonly` (i.e. mutable) fields, it's not recommended because it can break code that relies on object's hashcode consistency.\r\nDictionary is an example of a collection that will not tolerate hash code volatility.\r\nSee [Eric Lippert's blog post](https://blogs.msdn.microsoft.com/ericlippert/2011/02/28/guidelines-and-rules-for-gethashcode/) and [StackOverflow discussion](http://stackoverflow.com/questions/4718009/mutable-objects-and-hashcode) for more details.\r\n\r\nSecond step is to make the Equals() and GetHashCode() delegate result calculation to EqualityHelper class.\r\nThe simplest code will look as following:\r\n\r\n```cs\r\nnamespace ObEq.Tests\r\n{\r\n    public class Sample<T> : IMemberwiseComparable\r\n    {\r\n        private readonly T field1;\r\n        private readonly int field2;\r\n\r\n        public Sample(T1 t, int i)\r\n        {\r\n\t\t\tthis.field1 = t;\r\n\t\t\tthis.field2 = i;\r\n        }\r\n\r\n        public override bool Equals(object other)\r\n        {\r\n            return EqualityHelper.CalculateEquals(this, other as IMemberwiseComparable);\r\n        }\r\n\r\n        public override int GetHashCode()\r\n        {\r\n            return EqualityHelper.CalculateHashCode(EqualityMembers);\r\n        }\r\n\r\n        public object[] EqualityMembers => new[] { field1, field2 };\r\n    }\r\n}\r\n```\r\n\r\n### or wihtout implementing IMemberwiseComparable\r\n\r\nOtherwise, you may write a slightly different variation of the code.\r\nIn this scenario you have more control over equality calculation.\r\nAlso, there is no need to implement the IMemberwiseComparable interface.\r\n\r\nNotice that EqualityHelper::ReferencesEqual(object1, object2) is used to check whether the references are same or not;\r\nwhereas EqualityHelper::AllMembersEqual(equalityMembers1, equalityMembers2) is the method that does the actual fieldwise comparison for two objects.\r\n\r\n```cs\r\nprivate object[] EqualityMembers => new[] { field1, field2 };\r\n\r\npublic bool Equals(Sample<T> other)\r\n{\r\n\treturn EqualityHelper.AllMembersEqual(this.EqualityMembers, other.EqualityMembers);\r\n}\r\n\r\npublic override bool Equals(object other)\r\n{\r\n\treturn EqualityHelper.ReferencesEqual(this, other) ??\r\n\t\tEqualityHelper.AllMembersEqual(this.EqualityMembers, ((Sample<T1>)other).EqualityMembers);\r\n}\r\n\r\npublic override int GetHashCode()\r\n{\r\n\treturn EqualityHelper.CalculateHashCode(EqualityMembers);\r\n}\r\n```\r\n\r\n## References\r\n\r\n[MSDN page about GetHashCode()](https://msdn.microsoft.com/en-us/library/system.string.gethashcode(v=vs.110).aspx)\r\n\r\n[MSDN page about Equals() method](https://msdn.microsoft.com/en-us/library/ms173147(v=vs.80).aspx)\r\n\r\n## Installation\r\n\r\nObEq is a available in a form of a NuGet package.\r\nFollow regular installation process to bring it to your project.\r\nhttps://www.nuget.org/packages/ObEq/\r\n\r\n## Tests\r\n\r\nUnit tests are available in ObEq.Tests project.\r\n\r\n## License\r\n\r\nThe code is distributed under the MIT license.\r\n\r\n## Reporting an Issue\r\n\r\nReporting an issue, proposing a feature, or asking a question are all great ways to improve software quality.\r\n\r\nHere are a few important things that package contributors will expect to see in a new born GitHub issue:\r\n* the relevant version of the package;\r\n* the steps to reproduce;\r\n* the expected result;\r\n* the observed result;\r\n* some code samples illustrating current inconveniences and/or proposed improvements.\r\n\r\n## Contributing\r\n\r\nContribution is the best way to improve any project!\r\n\r\n1. Fork it!\r\n2. Create your feature branch (```git checkout -b my-new-feature```).\r\n3. Commit your changes (```git commit -am 'Added some feature'```)\r\n4. Push to the branch (```git push origin my-new-feature```)\r\n5. Create new Pull Request\r\n\r\n...or follow steps described in a nice [fork guide](http://kbroman.org/github_tutorial/pages/fork.html) by Karl Broman\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}